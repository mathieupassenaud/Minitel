/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of DWIW.xs. Do not edit this file, edit DWIW.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "DWIW.xs"
/*
Copyright (c) 2007-2010 Don Owens <don@regexguy.com>.  All rights reserved.

 This is free software; you can redistribute it and/or modify it under
 the Perl Artistic license.  You should have received a copy of the
 Artistic license with this distribution, in the file named
 "Artistic".  You may also obtain a copy from
 http://regexguy.com/license/Artistic

 This program is distributed in the hope that it will be
 useful, but WITHOUT ANY WARRANTY; without even the implied
 warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 PURPOSE.
*/

/* $Revision: 1675 $ */

/* #define PERL_NO_GET_CONTEXT */

#include "DWIW.h"
#include "old_common.h"

/*
#include "old_parse.h"
*/


/* get rid of "value computed is not used" warnings */
#define IGNORE_RV(x) (void)(x)

static SV *
vjson_encode_error(self_context * ctx, const char * file, int line_num, const char * fmt, va_list *ap_ptr) {
    SV * error = newSVpv("", 0);
    bool junk = 0;
    HV * error_data = Nullhv;

    sv_setpvf(error, "JSON::DWIW v%s - ", MOD_VERSION);

    sv_vcatpvfn(error, fmt, strlen(fmt), ap_ptr, (SV **)0, 0, &junk);

    error_data = newHV();
    ctx->error_data = newRV_noinc((SV *)error_data);

    IGNORE_RV(hv_store(error_data, "version", 7, newSVpvf("%s", MOD_VERSION), 0));

    return error;
}


#if defined(JSONEVT_HAVE_FULL_VARIADIC_MACROS)

static SV *
json_encode_error(self_context * ctx, const char * file, int line_num, const char * fmt, ...) {
    va_list ap;
    SV * error;
    
    va_start(ap, fmt);
    error = vjson_encode_error(ctx, file, line_num, fmt, &ap);
    va_end(ap);

    return error;
}


#if JSON_DO_EXTENDED_ERRORS


#define JSON_ENCODE_ERROR(ctx, ...) json_encode_error(ctx, __FILE__, __LINE__, __VA_ARGS__)

#else

#define JSON_ENCODE_ERROR(ctx, ...) json_encode_error(ctx, NULL, 0, __VA_ARGS__)

#endif

#else

static SV *
JSON_ENCODE_ERROR(self_context * ctx, const char * fmt, ...) {
    va_list ap;
    SV * error;

    va_start(ap, fmt);
    error = vjson_encode_error(ctx, NULL, 0, fmt, &ap);
    va_end(ap);

    return error;
}

#endif

#if DEBUG_UTF8
static STRLEN
print_hex(FILE * fp, const unsigned char * buf, STRLEN buf_len) {
    STRLEN i;
    UV c;

    for (i = 0; i < buf_len; i++) {
        c = buf[i];
        if (c & 0x80) {
            fprintf(fp, "\\x{%02"UVxf"}", c);
        }
        else {
            fwrite(&buf[i], 1, 1, fp);
        }
    }

    return i;
}

static STRLEN
print_hex_line(FILE * fp, const unsigned char * buf, STRLEN buf_len) {
    STRLEN i = print_hex(fp, buf, buf_len);
    
    fwrite("\n", 1, 1, fp);
    i++;

    return i;
}
#endif


static SV * to_json(self_context * self, SV * data_ref, int indent_level, unsigned int cur_level);
static SV * get_ref_addr(SV * ref);


#define JsSvLen(val) sv_len(val)

#define JsDumpSv(sv, flags) if (flags & kDumpVars) { sv_dump(sv); }

/*
static SV *
from_json_sv (SV * self, SV * data_sv, SV ** error_msg, int *throw_exception,
    SV * error_data_ref, SV * stats_data_ref) {
    STRLEN data_str_len;
    char * data_str;

    data_str = SvPV(data_sv, data_str_len);

    return from_json(self, data_str, data_str_len, error_msg, throw_exception, error_data_ref,
        stats_data_ref);
}
*/

static SV *
has_jsonevt() {
#ifdef HAVE_JSONEVT
    return newSVuv(1);
#else
    return newSV(0);
#endif
}

static SV *
deserialize_json(SV * self, char * data_str, STRLEN data_str_len) {
    SV * val;

    UNLESS (data_str) {
        /* return undef */
        return (SV *)&PL_sv_undef;
    }

    if (data_str_len == 0) {
        /* return empty string */
        val = newSVpv("", 0);
        return val;
    }
    
    val = do_json_parse_buf(self, data_str, data_str_len);

    return (SV *)val;
}

static SV *
deserialize_json_sv (SV * self, SV * data_sv) {
    STRLEN data_str_len;
    char * data_str;

    data_str = SvPV(data_sv, data_str_len);

    return deserialize_json(self, data_str, data_str_len);
}

/*
static int
get_unicode_char_count(SV * self, U8 *c_str, STRLEN len) {
    STRLEN i;
    U32 count = 0;

    for (i = 0; i < len; i++) {
        if (! UTF8_IS_INVARIANT(c_str[i])) {
            len = UTF8SKIP(&c_str[i]);
            i += len - 1;
            count++;
        }
    }

    return count;
}
*/

#if 0
static SV *
parse_json_file(SV * self, SV * file, SV * error_msg_ref) {
    SV * rv;
    SV * error_msg;
    SV * passed_error_msg_sv;
    int throw_exception = 0;
    char * data;
    STRLEN data_len;
    char * filename;
    char * filename_len;
    FILE * fp;

    filename = SvPV(file, filename_len);
    if (! filename || ! (fp = fopen(filename, "r")) ) {
        /* FIXME: put a good error msg here */
        return &PL_sv_undef;
    }

    

    /* FIXME: read from file here */

    error_msg = (SV *)&PL_sv_undef;
    rv = from_json(self, data, data_len, &error_msg, &throw_exception);
    if (SvOK(error_msg) && SvROK(error_msg_ref)) {
        passed_error_msg_sv = SvRV(error_msg_ref);
        sv_setsv(passed_error_msg_sv, error_msg);
    }

    return rv;
}
#endif

static char *
_safe_dup_buf(char *buf, uint32_t buf_len) {
    char *dest = (char *)malloc(buf_len + 1);

    memcpy(dest, buf, buf_len);
    dest[buf_len] = 0;

    return dest;
}

static SV *
escape_json_str(self_context * self, SV * sv_str) {
    U8 * data_str;
    STRLEN data_str_len;
    STRLEN needed_len = 0;
    STRLEN sv_pos = 0;
    uint32_t len = 0;
    U8 tmp_char = 0x00;
    SV * rv;
    UV this_uv = 0;
    U8 unicode_bytes[5];
    int escape_unicode = 0;
    int pass_bad_char = 0;
    uint32_t len32 = 0;
    char *err_str = Nullch;

    memzero(unicode_bytes, 5); /* memzero macro provided by Perl */

    UNLESS (SvOK(sv_str)) {
        return newSVpv("null", 4);
    }

    data_str = (U8 *)SvPV(sv_str, data_str_len);
    UNLESS (data_str) {
        return newSVpv("null", 4);
    }

    self->string_count++;

    if (data_str_len == 0) {
        /* empty string */
        return newSVpv("\"\"", 2);
    }

    if (self->flags & kEscapeMultiByte) {
        escape_unicode = 1;
    }

    /* get a better estimate of needed buffer size */
    needed_len = data_str_len * 2 + 2;

    rv = newSV(needed_len);
    SvUTF8_on(rv);
    sv_setpvn(rv, "\"", 1);

    /* printf("\tencoding string %s\n", data_str); */
    
#if DEBUG_UTF8
    fprintf(stderr, "\tencoding string ");
    print_hex_line(stderr, data_str, data_str_len);
    /* if (data_str[0] == 0xe4) { */
    sv_dump(sv_str);
        /* } */
    fprintf(stderr, "==========\n");
#endif
    
    for (sv_pos = 0; sv_pos < data_str_len; sv_pos++) {
        pass_bad_char = 0;

        /* this_uv = convert_utf8_to_uv(&data_str[sv_pos], &len); */
        this_uv = (UV)utf8_bytes_to_unicode((uint8_t *)(&data_str[sv_pos]), data_str_len - sv_pos, &len);
            
        if (len == 0) {
            len = 1;

            UNLESS (self->bad_char_policy) {
                /* default */
                this_uv = (UV)data_str[sv_pos];
                if (data_str_len < 40) {
                    err_str = _safe_dup_buf((char *)data_str, data_str_len);
                    self->error = JSON_ENCODE_ERROR(self,
                        "bad utf8 sequence starting with %#02"UVxf" - %s",
                        this_uv, (char *)data_str);
                    free(err_str);
                }
                else {
                    self->error = JSON_ENCODE_ERROR(self,
                        "bad utf8 sequence starting with %#02"UVxf, this_uv);
                }
                    
                sv_catpvn(rv, "\"", 1);
                return rv;
            }
            else if (self->bad_char_policy & kBadCharConvert) {
                this_uv = (UV)data_str[sv_pos];
            }
            else if (self->bad_char_policy & kBadCharPassThrough) {
                this_uv = (UV)data_str[sv_pos];
                pass_bad_char = 1;
            }
        }
            
        sv_pos += len - 1;

        switch (this_uv) {
          case '\\':
              sv_catpvn(rv, "\\\\", 2);
              break;
          case '"':
              sv_catpvn(rv, "\\\"", 2);
              break;
              /* 
          case '\'':
              sv_catpvn(rv, "\\'", 2);
              break;
              */

          case '/':
              if (self->flags & (kBareSolidus | kMinimalEscaping)) {
                  sv_catpvn(rv, "/", 1);
              }
              else {
                  sv_catpvn(rv, "\\/", 2);
              }

              break;
              
          case 0x08:
              if (self->flags & kMinimalEscaping) {
                  sv_catpvn(rv, "\x08", 1);
              }
              else {
                  sv_catpvn(rv, "\\b", 2);
              }
              break;
              
          case 0x0c:
              if (self->flags & kMinimalEscaping) {
                  sv_catpvn(rv, "\x0c", 1);
              }
              else {
                  sv_catpvn(rv, "\\f", 2);
              }
              break;
              
          case 0x0a:
              if (self->flags & kMinimalEscaping) {
                  sv_catpvn(rv, "\x0a", 1);
              }
              else {
                  sv_catpvn(rv, "\\n", 2);
              }
              break;
              
          case 0x0d:
              if (self->flags & kMinimalEscaping) {
                  sv_catpvn(rv, "\x0d", 1);
              }
              else {
                  sv_catpvn(rv, "\\r", 2);
              }
              break;
              
          case 0x09:
              if (self->flags & kMinimalEscaping) {
                  sv_catpvn(rv, "\x09", 1);
              }
              else {
                  sv_catpvn(rv, "\\t", 2);
              }
              break;
              
          default:
              if (this_uv < 0x1f) {
                  sv_catpvf(rv, "\\u%04"UVxf, this_uv);
              }
              else if (escape_unicode && ! UTF8_IS_INVARIANT(this_uv)) {
                  sv_catpvf(rv, "\\u%04"UVxf, this_uv);
              }
              else if (!pass_bad_char) {
                  len32 = common_utf8_unicode_to_bytes((uint32_t)this_uv, (uint8_t *)unicode_bytes);
                  if (len32 > 1) {
                      SvUTF8_on(rv);
                  }
                  sv_catpvn(rv, (char *)unicode_bytes, len32);
              }
              else {
                  tmp_char = (U8)this_uv;
                  sv_catpvn(rv, (char *)&tmp_char, 1);
              }

              break;              
        }
    }
    
    sv_catpvn(rv, "\"", 1);
    
    return rv;
}

static SV *
encode_array(self_context * self, AV * array, int indent_level, unsigned int cur_level) {
    SV * rsv = NULL;
    SV * tmp_sv = NULL;
    I32 max_i = av_len(array); /* max index, not length */
    I32 i;
    I32 j;
    SV ** element = NULL;
    I32 num_spaces = 0;
    MAGIC * magic_ptr = NULL;

    JsDumpSv((SV *)array, self->flags);

    cur_level++;
    UPDATE_CUR_LEVEL(self, cur_level);

    self->array_count++;

    if (self->flags & kPrettyPrint) {
        if (indent_level == 0) {
            rsv = newSVpv("[", 1);
        }
        else {
            num_spaces = indent_level * 4;
            rsv = newSV(num_spaces + 3);
            sv_setpvn(rsv, "\n", 1);
            for (i = 0; i < num_spaces; i++) {
                sv_catpvn(rsv, " ", 1);
            }
            sv_catpvn(rsv, "[", 1);
        }
    }
    else {
        rsv = newSVpv("[", 1);
    }

    num_spaces = (indent_level + 1) * 4;

    magic_ptr = mg_find((SV *)array, PERL_MAGIC_tied);

    for (i = 0; i <= max_i; i++) {
        element = av_fetch(array, i, 0);
        if (element && *element) {
            if (self->flags & kDumpVars) {
                fprintf(stderr, "array element:\n");
            }

            /* need to call mg_get(val) to get the actual value if this is a tied array */
            /* see sv_magic */
            if (magic_ptr || SvTYPE(*element) == SVt_PVMG) {
                /* mg_get(*element); */ /* causes assertion failure in perl 5.8.5 if tied scalar */
                SvGETMAGIC(*element);
            }

            tmp_sv = to_json(self, *element, indent_level + 1, cur_level);

            if (self->flags & kPrettyPrint) {
                sv_catpvn(rsv, "\n", 1);
                for (j = 0; j < num_spaces; j++) {
                    sv_catpvn(rsv, " ", 1);
                }
            }

            sv_catsv(rsv, tmp_sv);
            SvREFCNT_dec(tmp_sv);
            if (self->error) {
                SvREFCNT_dec(rsv);
                return (SV *)&PL_sv_undef;
            }
            tmp_sv = NULL;
        }
        else {
            /* error? */
            sv_catpvn(rsv, "null", 4);
        }

        if (i != max_i) {
            sv_catpvn(rsv, ",", 1);
        }
    }

    if (self->flags & kPrettyPrint) {
        sv_catpvn(rsv, "\n", 1);
        num_spaces = indent_level * 4;
        for (j = 0; j < num_spaces; j++) {
            sv_catpvn(rsv, " ", 1);
        }
    }
    sv_catpvn(rsv, "]", 1);

    return rsv;
}

static void
setup_self_context(SV *self_sv, self_context *self) {
    SV ** ptr = NULL;
    SV * self_hash = NULL;

    memzero((void *)self, sizeof(self_context));

    UNLESS (SvROK(self_sv)) {
        /* hmmm, this should always be a reference */
        return;
    }
    
    self_hash = SvRV(self_sv);

    /* HvUSEDKEYS(hv) */
    /* HvKEYS(hv) */
    if (HvKEYS(self_hash) == 0) {
        /* empty hash, so return early */
        return;
    }

    ptr = hv_fetch((HV *)self_hash, "bare_keys", 9, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->bare_keys = 1;
    }

    ptr = hv_fetch((HV *)self_hash, "use_exceptions", 14, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kUseExceptions;
    }

    self->bad_char_policy = get_bad_char_policy((HV *)self_hash);

    ptr = hv_fetch((HV *)self_hash, "dump_vars", 9, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kDumpVars;
    }

    ptr = hv_fetch((HV *)self_hash, "pretty", 6, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kPrettyPrint;
    }

    ptr = hv_fetch((HV *)self_hash, "escape_multi_byte", 17, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kEscapeMultiByte;
    }

    ptr = hv_fetch((HV *)self_hash, "ascii", 5, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kEscapeMultiByte;
    }

    ptr = hv_fetch((HV *)self_hash, "detect_circular_refs", 20, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->ref_track = newHV();
    }

    ptr = hv_fetch((HV *)self_hash, "bare_solidus", 12, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kBareSolidus;
    }

    ptr = hv_fetch((HV *)self_hash, "minimal_escaping", 16, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kMinimalEscaping;
    }

    ptr = hv_fetch((HV *)self_hash, "sort_keys", 9, 0);
    if (ptr && SvTRUE(*ptr)) {
        self->flags |= kSortKeys;
    }


#if JSON_DUMP_OPTIONS
    {
        char * char_policy = NULL;
        switch (self->bad_char_policy) {
          case kBadCharError:
              char_policy = "error";
              break;

          case kBadCharConvert:
              char_policy = "convert";
              break;

          case kBadCharPassThrough:
              char_policy = "pass_through";
              break;

          default:
              char_policy = "unrecognized bad_char policy";
              break;
        }

        fprintf(stderr, "\nBad char policy: %s\n", char_policy);

        if (self->flags & kUseExceptions) {
            fprintf(stderr, "Use Exceptions\n");
        }
        
        if (self->flags & kDumpVars) {
            fprintf(stderr, "Dump Vars\n");
        }

        if (self->flags & kPrettyPrint) {
            fprintf(stderr, "Pretty Print\n");
        }

        if (self->flags & kEscapeMultiByte) {
            fprintf(stderr, "Escape Multi-Byte Characters\n");
        }

        if (self-flags & kBareSolidus) {
            fprintf(stderr, "Don't escape solidus ('/')\n");
        }
        
        fprintf(stderr, "\n");
        fflush(stderr);
    }
#endif

}

static int
hash_key_can_be_bare(self_context * self, const char *key, STRLEN key_len) {
    U8 this_byte;
    STRLEN i;

    UNLESS (self->bare_keys) {
        return 0;
    }

    /* Only allow if 7-bit ascii, so use byte semantics, and only
       allow if alphanumeric and '_'.
    */
    for (i = 0; i < key_len; i++) {
        this_byte = *key;
        key++;
        UNLESS (this_byte == '_'
            || (this_byte >= 'A' && this_byte <= 'Z')
            || (this_byte >= 'a' && this_byte <= 'z')
            || (this_byte >= '0' && this_byte <= '9')
                ) {
            return 0;
        }
    }

    return 1;
}

static SV *
_encode_hash_entry(self_context *self, int first, HE * entry, const char *key, I32 key_len,
    SV *key_sv, SV *val, SV *rsv,
    int indent_level, unsigned int cur_level) {

    SV * tmp_sv = NULL;
    SV * tmp_sv2 = NULL;
    int i = 0;
    int num_spaces;

    num_spaces = (indent_level + 1) * 4;
    
    if (self->flags & kDumpVars) {
        fprintf(stderr, "hash key = %s\nval:\n", key);
    }
    
    if (self->flags & kPrettyPrint) {
        sv_catpvn(rsv, "\n", 1);
        for (i = 0; i < num_spaces; i++) {
            sv_catpvn(rsv, " ", 1);
        }
    }

    if (hash_key_can_be_bare(self, key, key_len)) {
        /* if the key can be bare, then it cannot have any hi-bits
           set, so no need to upgrade to utf-8
        */
        sv_catpvn(rsv, (char *)key, key_len);
    }
    else {
        tmp_sv = newSVpv((char *)key, key_len);

#ifdef IS_PERL_5_8
        if (HeKWASUTF8(entry)) {
            /* The hash key was utf-8 encoding, but the char * was

            given to us with as the decoded bytes (e.g., utf-8 =>
            latin1), so convert back to utf-8

            */
            sv_utf8_upgrade(tmp_sv);
        }
#endif

        tmp_sv2 = escape_json_str(self, tmp_sv);
        if (self->error) {
            SvREFCNT_dec(tmp_sv);
            SvREFCNT_dec(tmp_sv2);
            SvREFCNT_dec(rsv);
            return (SV *)&PL_sv_no;
        }

        sv_catsv(rsv, tmp_sv2);
        SvREFCNT_dec(tmp_sv);
        SvREFCNT_dec(tmp_sv2);
    }

    sv_catpvn(rsv, ":", 1);

    tmp_sv = to_json(self, val, indent_level + 2, cur_level);
    if (self->error) {
        SvREFCNT_dec(tmp_sv);
        SvREFCNT_dec(rsv);
        return (SV *)&PL_sv_no;
    }

    sv_catsv(rsv, tmp_sv);
    SvREFCNT_dec(tmp_sv);

    return (SV *)&PL_sv_yes;
}

static SV *
encode_hash(self_context * self, HV * hash, int indent_level, unsigned int cur_level) {
    SV * rsv = NULL;
    SV * sv = Nullsv;
    SV * key_sv = Nullsv;
    const char * key;
    I32 key_len;
    SV * val;
    int first = 1;
    int i;
    int num_spaces = 0;
    MAGIC * magic_ptr = NULL;
    HE * entry;
    SV * success = Nullsv;
    AV * keys = Nullav;
    SV ** svp = (SV **)0;
    STRLEN tmp_strlen = 0;
#if PERL_VERSION < 8
    SV * sort_keys = Nullsv;
#endif

    cur_level++;
    UPDATE_CUR_LEVEL(self, cur_level);

    self->hash_count++;

    if (self->flags & kPrettyPrint) {
        if (indent_level == 0) {
            rsv = newSVpv("{", 1);
        }
        else {
            num_spaces = indent_level * 4;
            rsv = newSV(num_spaces + 3);
            sv_setpvn(rsv, "\n", 1);
            for (i = 0; i < num_spaces; i++) {
                sv_catpvn(rsv, " ", 1);
            }
            sv_catpvn(rsv, "{", 1);

        }

    }
    else {
        rsv = newSVpv("{", 1);
    }

    JsDumpSv((SV *)hash, self->flags);

    magic_ptr = mg_find((SV *)hash, PERL_MAGIC_tied);
    
    num_spaces = (indent_level + 1) * 4;
    
    if (self->flags & kSortKeys) {
#if PERL_VERSION < 8
        /* old-style -- work around not ahveing sortsv() */
        sort_keys = sv_2mortal(newSVpvn("JSON::DWIW::_sort_keys", 22));

        /* FIXME: complete for Perl < 5.8 */
        dSP; ENTER; SAVETMPS; PUSHMARK(sp);
        XPUSHs(sv_2mortal(newRV_inc((SV *)hash))); PUTBACK;
        i = call_sv(sort_keys, G_SCALAR | G_EVAL);
        SPAGAIN;
        if (i) {
			sv = POPs;
			if (SvROK(sv) && (SvTYPE(SvRV(sv)) == SVt_PVAV))
			    keys = (AV*)SvREFCNT_inc(SvRV(sv));
        }
        UNLESS (keys) {
			warn("Sortkeys subroutine did not return ARRAYREF\n");
        }
        PUTBACK; FREETMPS; LEAVE;

#else
        keys = newAV();
        (void)hv_iterinit(hash);
        while ((entry = hv_iternext(hash))) {
			sv = hv_iterkeysv(entry);
			SvREFCNT_inc(sv);
			av_push(keys, sv);
        }

#ifdef USE_LOCALE_NUMERIC
        sortsv(AvARRAY(keys), av_len(keys)+1, IN_LOCALE ? Perl_sv_cmp_locale : Perl_sv_cmp);
#else
        sortsv(AvARRAY(keys), av_len(keys)+1, Perl_sv_cmp);
#endif

#endif

        for (i = 0; (I32)i <= av_len(keys); i++) {
            svp = av_fetch(keys, i, FALSE);
            key_sv = svp ? *svp : sv_mortalcopy(&PL_sv_undef);
            
            key = SvPV(key_sv, tmp_strlen);
            key_len = tmp_strlen;
            entry = hv_fetch_ent(hash, key_sv, 0, 0);
            /* key = (unsigned char *)hv_iterkey(entry, &key_len); */
            
            /*
            svp = hv_fetch(hash, key, SvUTF8(keysv) ? -key_len : keylen, 0); 
		    val = svp ? *svp : sv_mortalcopy(&PL_sv_undef);
            */
            val = hv_iterval(hash, entry);

            if (magic_ptr || SvTYPE(val) == SVt_PVMG) {
                /* mg_get(val); */ /* crashes in Perl 5.8.5 if doesn't have "get magic" */
                SvGETMAGIC(val);
            }

            UNLESS (first) {
                sv_catpvn(rsv, ",", 1);
            }

            /* ref cnt for rsv is decremented in encode_hash_entry() if there is an error */
            success = _encode_hash_entry(self, first, entry, key, key_len, key_sv, val, rsv,
                indent_level, cur_level);

            if (success != &PL_sv_yes) {
                SvREFCNT_dec(keys);

                return &PL_sv_undef;
            }

            first = 0;
        }

        SvREFCNT_dec(keys); keys = Nullav;
    }
    else {

        /* non-sorted keys */
        hv_iterinit(hash);
        /* while ( (val = hv_iternextsv(hash, (char **)&key, &key_len)) ) { */
        while (1) {
            entry = hv_iternext(hash);
            UNLESS (entry) {
                break;
            }

            /* key_sv = HeSVKEY(entry); */
            key = hv_iterkey(entry, &key_len);
            /* key = (U8 *)HePV(entry, key_len); */
            val = hv_iterval(hash, entry);

            /* need to call mg_get(val) to get the actual value if this is a tied hash */
            /* see sv_magic */
            if (magic_ptr || SvTYPE(val) == SVt_PVMG) {
                /* mg_get(val); */ /* crashes in Perl 5.8.5 if doesn't have "get magic" */
                SvGETMAGIC(val);
            }

            UNLESS (first) {
                sv_catpvn(rsv, ",", 1);
            }

            /* ref cnt for rsv is decremented in encode_hash_entry() if there is an error */
            success = _encode_hash_entry(self, first, entry, key, key_len, Nullsv, val, rsv,
                indent_level, cur_level);
            if (success != &PL_sv_yes) {
                return &PL_sv_undef;
            }

            first = 0;
        }
    }

    if (self->flags & kPrettyPrint) {
        sv_catpvn(rsv, "\n", 1);
        num_spaces = indent_level * 4;
        for (i = 0; i < num_spaces; i++) {
            sv_catpvn(rsv, " ", 1);
        }
    }
    sv_catpvn(rsv, "}", 1);

    return rsv;
}

#if 0
static SV *
old_encode_hash(self_context * self, HV * hash, int indent_level, unsigned int cur_level) {

    SV * rsv = NULL;
    SV * tmp_sv = NULL;
    SV * tmp_sv2 = NULL;
    U8 * key;
    I32 key_len;
    SV * val;
    int first = 1;
    int i;
    int num_spaces = 0;
    MAGIC * magic_ptr = NULL;
    HE * entry;
    /* SV * key_sv = NULL; */


    if (self->flags & kSortKeys) {
        return encode_hash2(self, hash, indent_level, cur_level);
    }

    cur_level++;
    UPDATE_CUR_LEVEL(self, cur_level);

    self->hash_count++;

    if (self->flags & kPrettyPrint) {
        if (indent_level == 0) {
            rsv = newSVpv("{", 1);
        }
        else {
            num_spaces = indent_level * 4;
            rsv = newSV(num_spaces + 3);
            sv_setpvn(rsv, "\n", 1);
            for (i = 0; i < num_spaces; i++) {
                sv_catpvn(rsv, " ", 1);
            }
            sv_catpvn(rsv, "{", 1);

        }

    }
    else {
        rsv = newSVpv("{", 1);
    }

    JsDumpSv((SV *)hash, self->flags);

    magic_ptr = mg_find((SV *)hash, PERL_MAGIC_tied);
    
    num_spaces = (indent_level + 1) * 4;

    /* non-sorted keys */
    hv_iterinit(hash);
    /* while ( (val = hv_iternextsv(hash, (char **)&key, &key_len)) ) { */
    while (1) {
        entry = hv_iternext(hash);
        UNLESS (entry) {
            break;
        }

        /* key_sv = HeSVKEY(entry); */
        key = (unsigned char *)hv_iterkey(entry, &key_len);
        /* key = (U8 *)HePV(entry, key_len); */
        val = hv_iterval(hash, entry);

        UNLESS (first) {
            sv_catpvn(rsv, ",", 1);
        }

        first = 0;

        /* need to call mg_get(val) to get the actual value if this is a tied hash */
        /* see sv_magic */
        if (magic_ptr || SvTYPE(val) == SVt_PVMG) {
            /* mg_get(val); */ /* crashes in Perl 5.8.5 if doesn't have "get magic" */
            SvGETMAGIC(val);
        }

        if (self->flags & kDumpVars) {
            fprintf(stderr, "hash key = %s\nval:\n", key);
        }
    
        if (self->flags & kPrettyPrint) {
            sv_catpvn(rsv, "\n", 1);
            for (i = 0; i < num_spaces; i++) {
                sv_catpvn(rsv, " ", 1);
            }
        }

        if (hash_key_can_be_bare(self, key, key_len)) {
            /* if the key can be bare, then it cannot have any hi-bits
               set, so no need to upgrade to utf-8
            */
            sv_catpvn(rsv, (char *)key, key_len);
        }
        else {
            tmp_sv = newSVpv((char *)key, key_len);

#ifdef IS_PERL_5_8
            if (HeKWASUTF8(entry)) {
                /* The hash key was utf-8 encoding, but the char * was

                   given to us with as the decoded bytes (e.g., utf-8 =>
                   latin1), so convert back to utf-8

                */
                sv_utf8_upgrade(tmp_sv);
            }
#endif

            tmp_sv2 = escape_json_str(self, tmp_sv);
            if (self->error) {
                SvREFCNT_dec(tmp_sv);
                SvREFCNT_dec(tmp_sv2);
                SvREFCNT_dec(rsv);
                return (SV *)&PL_sv_undef;
            }

            sv_catsv(rsv, tmp_sv2);
            SvREFCNT_dec(tmp_sv);
            SvREFCNT_dec(tmp_sv2);
        }

        sv_catpvn(rsv, ":", 1);

        tmp_sv = to_json(self, val, indent_level + 2, cur_level);
        if (self->error) {
            SvREFCNT_dec(tmp_sv);
            SvREFCNT_dec(rsv);
            return (SV *)&PL_sv_undef;
        }

        sv_catsv(rsv, tmp_sv);
        SvREFCNT_dec(tmp_sv);
    }

    if (self->flags & kPrettyPrint) {
        sv_catpvn(rsv, "\n", 1);
        num_spaces = indent_level * 4;
        for (i = 0; i < num_spaces; i++) {
            sv_catpvn(rsv, " ", 1);
        }
    }
    sv_catpvn(rsv, "}", 1);

    return rsv;
}
#endif

static SV *
to_json(self_context * self, SV * data_ref, int indent_level, unsigned int cur_level) {
    SV * data;
    int type;
    SV * rsv = newSVpv("", 0);
    SV * tmp = NULL;
    STRLEN before_len = 0;
    U8 * data_str = NULL;
    STRLEN start = 0;
    STRLEN len = 0;
    SV * ref_tmp = NULL;
    IV int_val = 0;
    UV uint_val = 0;
    /*
    NV float_val = 0;
    STRLEN pvlen = 0;
    */

    JsDumpSv(data_ref, self->flags);

    UNLESS (SvROK(data_ref)) {
        data = data_ref;
        if (SvOK(data)) {


            /* scalar */
            type = SvTYPE(data);
            switch (type) {
              case SVt_NULL:
                /* undef? */
                sv_setpvn(rsv, "null", 4);
                return rsv;
                break;

              case SVt_IV:
              case SVt_NV:
                  before_len = JsSvLen(rsv);

                  if (type == SVt_IV) {
                      if (SvIsUV(data)) {
                          uint_val = SvUVX(data);
                          sv_catpvf(rsv, "%"UVuf, uint_val);
                      }
                      else {
                          int_val = SvIVX(data);
                          sv_catpvf(rsv, "%"IVdf, int_val);
                      }
                      
                  }
                  else {
                      tmp = newSVsv(data);
                      sv_catsv(rsv, tmp);
                      SvREFCNT_dec(tmp);
                      /*
                      float_val = SvNVX(data);
                      sv_catpvf(rsv, "%"NVgf, float_val);
                      */
                  }

                  self->number_count++;

                  if (JsSvLen(rsv) == before_len) {
                      sv_catpvn(rsv, "\"\"", 2);
                  }
                  return rsv;
                  break;

              case SVt_PV:
                  sv_catsv(rsv, data);
                  tmp = rsv;
                  rsv = escape_json_str(self, tmp);
                  SvREFCNT_dec(tmp);
                  return rsv; /* this works for the error case as well */
                  break;
                  
              case SVt_PVIV:
              case SVt_PVNV:
                  sv_catsv(rsv, data);
                  tmp = rsv;
                  rsv = escape_json_str(self, tmp);
                  SvREFCNT_dec(tmp);
                  return rsv;
                  break;

              case SVt_PVLV:
                  sv_catsv(rsv, data);
                  tmp = rsv;
                  rsv = escape_json_str(self, tmp);
                  SvREFCNT_dec(tmp);
                  return rsv;
                  break;

              default:
                  /* now what? */
                  sv_catsv(rsv, data);
                  tmp = rsv;
                  rsv = escape_json_str(self, tmp);
                  SvREFCNT_dec(tmp);
                  return rsv;
                  break;
            }
        }
        else {
            /* undef */
            sv_setpvn(rsv, "null", 4);
            return rsv;
        }
    }

    if (self->ref_track) {
        ref_tmp = get_ref_addr(data_ref);
        if (hv_exists_ent(self->ref_track, ref_tmp, 0)) {
            SvREFCNT_dec(ref_tmp);
            /* return a stringified version */
            sv_catpvn(rsv, "\"circular ref: ", 15);
            sv_catsv(rsv, data_ref);
            sv_catpvn(rsv, "\"", 1);
            return rsv;
        }
        else {
            IGNORE_RV(hv_store_ent(self->ref_track, ref_tmp, newSV(0), 0));
            SvREFCNT_dec(ref_tmp);
        }
    }

    if (sv_isobject(data_ref)) {
        if (sv_isa(data_ref, "JSON::DWIW::Boolean")) {
            if (SvTRUE(data_ref)) {
                sv_setpvn(rsv, "true", 4);
                self->bool_count++;
                return rsv;
            }
            else {
                sv_setpvn(rsv, "false", 5);
                self->bool_count++;
                return rsv;
            }
        }
        else if (sv_derived_from(data_ref, "Math::BigInt")
            || sv_derived_from(data_ref, "Math::BigFloat")) {
            tmp = newSVpv("", 0);
            sv_catsv(tmp, data_ref);
            data_str = (U8 *)SvPV(tmp, before_len);

            if (before_len > 0) {
                start = 0;
                len = before_len;
                if (data_str[0] == '+') {
                    start++;
                    len--;
                }

                if (data_str[before_len - 1] == '.') {
                    len--;
                }

                sv_catpvn(rsv, (char *)data_str + start, len);

            }
            else {
                sv_setpvn(rsv, "\"\"", 2);
            }

            SvREFCNT_dec(tmp);

            return rsv;
        }
    }
    
    data = SvRV(data_ref);
    if (SvROK(data)) {
        /* reference to a referrence */
        sv_catsv(rsv, data_ref);
        tmp = rsv;
        rsv = escape_json_str(self, tmp);
        SvREFCNT_dec(tmp);
        
        return rsv;
    }

    type = SvTYPE(data);

    switch (type) {
      case SVt_NULL:
        /* undef ? */
        sv_setpvn(rsv, "null", 4);
        return rsv;
        break;

      case SVt_IV:
      case SVt_NV:
          before_len = JsSvLen(rsv);
          sv_catsv(rsv, data);
          if (JsSvLen(rsv) == before_len) {
              sv_catpvn(rsv, "\"\"", 2);
          }

        return rsv;
        break;

      case SVt_PV:
        sv_catsv(rsv, data);
        tmp = rsv;
        rsv = escape_json_str(self, tmp);
        SvREFCNT_dec(tmp);
        return rsv;
        break;

      case SVt_PVIV:
      case SVt_PVNV:
          sv_catsv(rsv, data);
          tmp = rsv;
          rsv = escape_json_str(self, tmp);
          SvREFCNT_dec(tmp);
          return rsv;
          break;

      case SVt_PVAV: /* array */
          SvREFCNT_dec(rsv);
          return encode_array(self, (AV *)data, indent_level, cur_level);
        break;

      case SVt_PVHV: /* hash */
          SvREFCNT_dec(rsv);
          return encode_hash(self, (HV *)data, indent_level, cur_level);
          break;

      case SVt_PVCV: /* code */
          sv_catsv(rsv, data_ref);
          tmp = rsv;
          rsv = escape_json_str(self, tmp);
          SvREFCNT_dec(tmp);

          return rsv;
          /*
            sv_setpvn(rsv, "\"code\"", 6);
            return rsv;
          */

        break;

      case SVt_PVGV: /* glob */
          sv_catsv(rsv, data_ref);
          tmp = rsv;
          rsv = escape_json_str(self, tmp);
          SvREFCNT_dec(tmp);

          return rsv;
          break;

      case SVt_PVIO:
          sv_catsv(rsv, data);
          tmp = rsv;
          rsv = escape_json_str(self, tmp);
          SvREFCNT_dec(tmp);
          return rsv;
          break;

      case SVt_PVMG: /* blessed or magical scalar */
          if (sv_isobject(data_ref)) {
              sv_catsv(rsv, data);
              tmp = rsv;
              rsv = escape_json_str(self, tmp);
              SvREFCNT_dec(tmp);
              
              return rsv;
          }
          else {
              sv_catsv(rsv, data);
              tmp = rsv;
              rsv = escape_json_str(self, tmp);
              SvREFCNT_dec(tmp);
              
              return rsv;
          }
          break;
          
      default:
          sv_catsv(rsv, data);
          tmp = rsv;
          rsv = escape_json_str(self, tmp);
          SvREFCNT_dec(tmp);
          
          return rsv;
          
/*        sv_setpvn(rsv, "unknown type", 12); */
/*        return rsv; */
              
          break;
    }

    sv_setpvn(rsv, "unknown type 2", 14);
    return rsv;

}

static int
set_encode_stats(self_context * ctx, SV * stats_data_ref) {
    SV * data = Nullsv;

    if (SvOK(stats_data_ref) && SvROK(stats_data_ref)) {
        data = SvRV(stats_data_ref);
        
        /* FIXME: should destroy these if the store fails */

        /*
        hv_store((HV *)data, "max_string_bytes", 16, newSVuv(ctx->longest_string_bytes), 0);
        hv_store((HV *)data, "max_string_chars", 16, newSVuv(ctx->longest_string_chars), 0);
        hv_store((HV *)data, "nulls", 5, newSVuv(ctx->null_count), 0);
        */

        /*
        hv_store((HV *)data, "strings", 7, newSVuv(ctx->string_count), 0);
        hv_store((HV *)data, "bools", 5, newSVuv(ctx->bool_count), 0);        
        hv_store((HV *)data, "numbers", 7, newSVuv(ctx->number_count), 0);
        */

        IGNORE_RV(hv_store((HV *)data, "hashes", 6, newSVuv(ctx->hash_count), 0));
        IGNORE_RV(hv_store((HV *)data, "arrays", 6, newSVuv(ctx->array_count), 0));
        IGNORE_RV(hv_store((HV *)data, "max_depth", 9, newSVuv(ctx->deepest_level), 0));

    }

    return 1;
}

static SV *
has_mmap() {
#ifdef HAS_MMAP
    return &PL_sv_yes;
#else
    return &PL_sv_no;
#endif
}

static SV *
parse_mmap_file(SV * self, SV * file, SV * error_msg_ref) {
#if USE_MMAP
    char * filename;
    STRLEN filename_len;
    void * base;
    int fd = -1;
    struct stat file_info;
    size_t len = 0;
    SV * rv;
    int throw_exception = 0;
    SV * error_msg = &PL_sv_undef;
    SV * passed_error_msg_sv;

    UNLESS (SvOK(file)) {
        return &PL_sv_undef;
    }

    filename = (char *)SvPV(file, filename_len);
    fd = open(filename, O_RDONLY, 0644);
    if (fd < 0) {
        return &PL_sv_undef;
    }

    if (fstat(fd, &file_info)) {
        return &PL_sv_undef;
    }

    /* FIXME: check here to see if file size too big, e.g., > 2GB */

    len = file_info.st_size;

    base = mmap(NULL, len, PROT_READ, 0, fd, 0);

    if (base == MAP_FAILED) {
        printf("mmap failed\n");
        return &PL_sv_undef;
    }

    fread(base, 1, len, stdout);

    rv = from_json(self, base, len, &error_msg, &throw_exception);
    if (SvOK(error_msg) && SvROK(error_msg_ref)) {
        passed_error_msg_sv = SvRV(error_msg_ref);
        sv_setsv(passed_error_msg_sv, error_msg);
    }

    munmap(base, len);
#else
    return &PL_sv_undef;
#endif
}

static SV *
get_ref_addr(SV * ref) {
    SV * addr_str = Nullsv;
    SV * sv_addr = Nullsv;
    char * str = Nullch;

    if (SvROK(ref)) {
        sv_addr = SvRV(ref);
        str = form("%"UVuf"", PTR2UV((void *)sv_addr));
        addr_str = newSVpvn(str, strlen(str));
    }
    else {
        return newSV(0);
    }

    return addr_str;
}

static SV *
get_ref_type(SV * ref) {
    UNLESS (SvROK(ref)) {
        return newSV(0);
    }

    /* FIXME: complete the type checks here */

    return newSV(0);
}


#line 1509 "DWIW.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 1651 "DWIW.c"

XS_EUPXS(XS_JSON__DWIW_do_dummy_parse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_do_dummy_parse)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, str");
    {
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	str = ST(1)
;
#line 1507 "DWIW.xs"
    RETVAL = do_json_dummy_parse(self, str);
#line 1667 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_has_deserialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_has_deserialize)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	RETVAL;
#line 1514 "DWIW.xs"
    items = items;
    RETVAL = has_jsonevt();
#line 1685 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_deserialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_deserialize)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "data, ...");
    {
#line 1526 "DWIW.xs"
    SV * self = Nullsv;
    SV * rv;

#line 1705 "DWIW.c"
	SV *	RETVAL;
	SV *	data = ST(0)
;
#line 1530 "DWIW.xs"
    if (items > 1) {
        self = (SV *)ST(1);
    }

    /* avoid compiler warnings about unused variable */
    ix = ix;

    rv = deserialize_json_sv(self, data);

    RETVAL = rv;

#line 1721 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_deserialize_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_deserialize_file)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "file, ...");
    {
#line 1550 "DWIW.xs"
    SV * self = Nullsv;
    SV * rv;

#line 1741 "DWIW.c"
	SV *	RETVAL;
	SV *	file = ST(0)
;
#line 1554 "DWIW.xs"
    if (items > 1) {
        self = (SV *)ST(1);
    }

    /* avoid compiler warnings about unused variable */
    ix = ix;

    rv = do_json_parse_file(self, file);

    RETVAL = rv;

#line 1757 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW__xs_to_json); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW__xs_to_json)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, data, error_msg_ref, error_data_ref, stats_ref");
    {
#line 1572 "DWIW.xs"
     self_context self_context;
     SV * rv;
     int indent_level = 0;
     SV * passed_error_data_sv = Nullsv;

#line 1778 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	data = ST(1)
;
	SV *	error_msg_ref = ST(2)
;
	SV *	error_data_ref = ST(3)
;
	SV *	stats_ref = ST(4)
;
#line 1578 "DWIW.xs"
     setup_self_context(self, &self_context);
     rv = to_json(&self_context, data, indent_level, 0);

    if (SvOK(stats_ref)) {
        set_encode_stats(&self_context, stats_ref);
    }

    if (self_context.error) {
        sv_setsv(SvRV(error_msg_ref), self_context.error);

        if (SvOK(error_data_ref) && SvROK(error_data_ref) && self_context.error_data) {
            passed_error_data_sv = SvRV(error_data_ref);
            sv_setsv(passed_error_data_sv, self_context.error_data);
        }

    }

    if (self_context.ref_track) {
        SvREFCNT_dec(self_context.ref_track);
        self_context.ref_track = Nullhv;
    }

     RETVAL = rv;

#line 1815 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_have_big_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_have_big_int)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 1608 "DWIW.xs"
    SV * rsv = newSV(0);
    int rv;

#line 1834 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
#line 1612 "DWIW.xs"
    self = self;
    rv = have_bigint();
    if (rv) {
        sv_setsv(rsv, &PL_sv_yes);
    } 
    else {
        sv_setsv(rsv, &PL_sv_no);
    }

    RETVAL = rsv;

#line 1850 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_have_big_float); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_have_big_float)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 1629 "DWIW.xs"
    SV * rsv = newSV(0);
    int rv;

#line 1869 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
#line 1633 "DWIW.xs"
    self = self; /* get rid of compiler warnings */
    rv = have_bigfloat();
    if (rv) {
        sv_setsv(rsv, &PL_sv_yes);
    } 
    else {
        sv_setsv(rsv, &PL_sv_no);
    }

    RETVAL = rsv;

#line 1885 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_size_of_uv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_size_of_uv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 1650 "DWIW.xs"
    SV * rsv = newSV(0);

#line 1903 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
#line 1653 "DWIW.xs"
    self = self; /* get rid of compiler warnings */
    sv_setuv(rsv, UVSIZE);

    RETVAL = rsv;

#line 1913 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_peek_scalar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_peek_scalar)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, val");
    {
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	val = ST(1)
;
#line 1664 "DWIW.xs"
    self = self; /* get rid of compiler warnings */

    sv_dump(val);

    RETVAL = &PL_sv_yes;

#line 1940 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_has_high_bit_bytes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_has_high_bit_bytes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, val");
    {
#line 1676 "DWIW.xs"
    U8 * s;
    STRLEN len;
    STRLEN i;

#line 1960 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	val = ST(1)
;
#line 1681 "DWIW.xs"
    self = self;
    RETVAL = &PL_sv_no;
    s = (U8 *)SvPV(val, len);

    for (i = 0; i < len; i++) {
        if (s[i] > 0x80) {
            RETVAL = &PL_sv_yes;
        }
    }

#line 1977 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_is_valid_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_is_valid_utf8)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, str");
    {
#line 1698 "DWIW.xs"
    SV * rv = &PL_sv_no;
    U8 * s;
    STRLEN len;

#line 1997 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	str = ST(1)
;
#line 1703 "DWIW.xs"
    self = self;
    s = (U8 *)SvPV(str, len);
    if (is_utf8_string(s, len)) {
        rv = &PL_sv_yes;
    }

    RETVAL = rv;

#line 2012 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_upgrade_to_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_upgrade_to_utf8)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, str");
    {
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	str = ST(1)
;
#line 1717 "DWIW.xs"
    self = self;
    sv_utf8_upgrade(str);

    if (GIMME_V == G_VOID) {
        RETVAL = &PL_sv_yes;
    }
    else {
        RETVAL = newSVsv(str);
    }

#line 2043 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_flagged_as_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_flagged_as_utf8)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, str");
    {
#line 1733 "DWIW.xs"
    SV * rv = &PL_sv_no;

#line 2061 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	str = ST(1)
;
#line 1736 "DWIW.xs"
    self = self;
    if (SvUTF8(str)) {
        rv = &PL_sv_yes;
    }

    RETVAL = rv;

#line 2075 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_flag_as_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_flag_as_utf8)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, str");
    {
#line 1749 "DWIW.xs"
    SV * rv = &PL_sv_yes;

#line 2093 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	str = ST(1)
;
#line 1752 "DWIW.xs"
    self = self;
    SvUTF8_on(str);

    RETVAL = rv;

#line 2105 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_unflag_as_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_unflag_as_utf8)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, str");
    {
#line 1763 "DWIW.xs"
    SV * rv = &PL_sv_yes;

#line 2123 "DWIW.c"
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	str = ST(1)
;
#line 1766 "DWIW.xs"
    self = self;
    SvUTF8_off(str);

    RETVAL = rv;

#line 2135 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_code_point_to_utf8_str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_code_point_to_utf8_str)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "SV *, code_point_sv");
    {
#line 1777 "DWIW.xs"
    UV code_point;
    U8 utf8_bytes[5];
    SV * rv = Nullsv;
    uint32_t len32 = 0;

#line 2156 "DWIW.c"
	SV *	RETVAL;
	SV *	code_point_sv = ST(1)
;
#line 1783 "DWIW.xs"
    utf8_bytes[4] = '\x00';
    code_point = SvUV(code_point_sv);

    len32 = common_utf8_unicode_to_bytes((uint32_t)code_point, (uint8_t *)utf8_bytes);
    utf8_bytes[len32] = '\x00';

    if (len32) {
        rv = newSVpv((char *)utf8_bytes, (STRLEN)len32);
        SvUTF8_on(rv);
    }
    else {
        rv = newSV(0);
    }

    RETVAL = rv;

#line 2177 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_code_point_to_hex_bytes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_code_point_to_hex_bytes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "SV *, code_point_sv");
    {
#line 1805 "DWIW.xs"
    UV code_point;
    U8 utf8_bytes[5];
    SV * rv;
    uint32_t len32 = 0;

#line 2198 "DWIW.c"
	SV *	RETVAL;
	SV *	code_point_sv = ST(1)
;
#line 1811 "DWIW.xs"
    utf8_bytes[4] = '\x00';
    code_point = SvUV(code_point_sv);
    rv = newSVpv("", 0);

    len32 = common_utf8_unicode_to_bytes((uint32_t)code_point, (uint8_t *) utf8_bytes);
    utf8_bytes[len32] = '\x00';

    if (len32) {
        uint32_t i;
        for (i = 0; i < len32; i++) {
            sv_catpvf(rv, "\\x%02x", (unsigned int)utf8_bytes[i]);
        }
    }
    else {

    }

    RETVAL = rv;

#line 2222 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_bytes_to_code_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_bytes_to_code_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "SV *, bytes");
    {
#line 1836 "DWIW.xs"
    U8 * data_str;
    STRLEN data_str_len;
    AV * array = newAV();
    STRLEN len = 0;
    UV this_char;
    STRLEN pos = 0;
    I32 max_i;
    SV * sv = NULL;
    I32 i;
    SV ** element;

#line 2249 "DWIW.c"
	SV *	RETVAL;
	SV *	bytes = ST(1)
;
#line 1848 "DWIW.xs"
    if (SvROK(bytes) && SvTYPE(SvRV(bytes)) == SVt_PVAV) {
        AV * av = (AV *)SvRV(bytes);
        max_i = av_len(av);
        sv = newSV(max_i);
        sv_setpvn(sv, "", 0);

        for (i = 0; i <= max_i; i++) {
            element = av_fetch(av, i , 0);
            if (element && *element) {
                this_char = SvUV(*element);
                fprintf(stderr, "%02"UVxf"\n", this_char);
            }
            else {
                this_char = 0;
            }
            sv_catpvf(sv, "%c", (unsigned char)this_char);
        }
        bytes = sv;
     }

    data_str = (U8 *)SvPV(bytes, data_str_len);

    while (pos < data_str_len) {
        this_char = convert_utf8_to_uv(&data_str[pos], &len);
        pos += len;
        av_push(array, newSVuv(this_char));
    }

    if (sv) {
        SvREFCNT_dec(sv);
    }

     RETVAL = newRV_noinc((SV *)array);

#line 2288 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW__has_mmap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW__has_mmap)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 1888 "DWIW.xs"
 RETVAL = has_mmap();

#line 2307 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW__parse_mmap_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW__parse_mmap_file)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, file, error_msg_ref");
    {
	SV *	RETVAL;
	SV *	self = ST(0)
;
	SV *	file = ST(1)
;
	SV *	error_msg_ref = ST(2)
;
#line 1897 "DWIW.xs"
 RETVAL = parse_mmap_file(self, file, error_msg_ref);

#line 2332 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW__check_scalar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW__check_scalar)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "SV *, the_scalar");
    {
	SV *	RETVAL;
	SV *	the_scalar = ST(1)
;
#line 1905 "DWIW.xs"
 fprintf(stderr, "SV * at addr %"UVxf"\n", PTR2UV(the_scalar));
 sv_dump(the_scalar);
 if (SvROK(the_scalar)) {
    printf("\ndereferenced:\n");
    fprintf(stderr, "SV * at addr %"UVxf"\n", PTR2UV(SvRV(the_scalar)));
    sv_dump(SvRV(the_scalar));
 }
 RETVAL = &PL_sv_yes;

#line 2360 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_skip_deserialize_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_skip_deserialize_file)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 1920 "DWIW.xs"
 RETVAL = &PL_sv_no;
#line 2378 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_get_ref_addr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_get_ref_addr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	RETVAL;
	SV *	ref = ST(0)
;
#line 1927 "DWIW.xs"
 RETVAL = get_ref_addr(ref);
#line 2398 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_JSON__DWIW_get_ref_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_JSON__DWIW_get_ref_type)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	RETVAL;
	SV *	ref = ST(0)
;
#line 1934 "DWIW.xs"
 RETVAL = get_ref_type(ref);
#line 2418 "DWIW.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_JSON__DWIW); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_JSON__DWIW)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        newXS("JSON::DWIW::do_dummy_parse", XS_JSON__DWIW_do_dummy_parse, file);
        newXS("JSON::DWIW::has_deserialize", XS_JSON__DWIW_has_deserialize, file);
        cv = newXS("JSON::DWIW::deserialize_json", XS_JSON__DWIW_deserialize, file);
        XSANY.any_i32 = 2;
        cv = newXS("JSON::DWIW::deserialize", XS_JSON__DWIW_deserialize, file);
        XSANY.any_i32 = 0;
        cv = newXS("JSON::DWIW::load", XS_JSON__DWIW_deserialize, file);
        XSANY.any_i32 = 1;
        cv = newXS("JSON::DWIW::load_file", XS_JSON__DWIW_deserialize_file, file);
        XSANY.any_i32 = 1;
        cv = newXS("JSON::DWIW::deserialize_file", XS_JSON__DWIW_deserialize_file, file);
        XSANY.any_i32 = 0;
        newXS("JSON::DWIW::_xs_to_json", XS_JSON__DWIW__xs_to_json, file);
        newXS("JSON::DWIW::have_big_int", XS_JSON__DWIW_have_big_int, file);
        newXS("JSON::DWIW::have_big_float", XS_JSON__DWIW_have_big_float, file);
        newXS("JSON::DWIW::size_of_uv", XS_JSON__DWIW_size_of_uv, file);
        newXS("JSON::DWIW::peek_scalar", XS_JSON__DWIW_peek_scalar, file);
        newXS("JSON::DWIW::has_high_bit_bytes", XS_JSON__DWIW_has_high_bit_bytes, file);
        newXS("JSON::DWIW::is_valid_utf8", XS_JSON__DWIW_is_valid_utf8, file);
        newXS("JSON::DWIW::upgrade_to_utf8", XS_JSON__DWIW_upgrade_to_utf8, file);
        newXS("JSON::DWIW::flagged_as_utf8", XS_JSON__DWIW_flagged_as_utf8, file);
        newXS("JSON::DWIW::flag_as_utf8", XS_JSON__DWIW_flag_as_utf8, file);
        newXS("JSON::DWIW::unflag_as_utf8", XS_JSON__DWIW_unflag_as_utf8, file);
        newXS("JSON::DWIW::code_point_to_utf8_str", XS_JSON__DWIW_code_point_to_utf8_str, file);
        newXS("JSON::DWIW::code_point_to_hex_bytes", XS_JSON__DWIW_code_point_to_hex_bytes, file);
        newXS("JSON::DWIW::bytes_to_code_points", XS_JSON__DWIW_bytes_to_code_points, file);
        newXS("JSON::DWIW::_has_mmap", XS_JSON__DWIW__has_mmap, file);
        newXS("JSON::DWIW::_parse_mmap_file", XS_JSON__DWIW__parse_mmap_file, file);
        newXS("JSON::DWIW::_check_scalar", XS_JSON__DWIW__check_scalar, file);
        newXS("JSON::DWIW::skip_deserialize_file", XS_JSON__DWIW_skip_deserialize_file, file);
        newXS("JSON::DWIW::get_ref_addr", XS_JSON__DWIW_get_ref_addr, file);
        newXS("JSON::DWIW::get_ref_type", XS_JSON__DWIW_get_ref_type, file);
    }
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

